{"name":"Optimus","tagline":"DOM Transcoder","body":"Optimus\r\n=======\r\n\r\n[![Build Status](https://secure.travis-ci.org/RobMasters/Optimus.png?branch=master)](http://travis-ci.org/RobMasters/Optimus)\r\n\r\n_The prime server-side way to manage DOM transformations_\r\n\r\n## Installation\r\n\r\n```\r\n$ git clone https://github.com/RobMasters/Optimus.git\r\n$ cd Optimus\r\n\r\n$ curl -sS https://getcomposer.org/installer | php\r\n$ php composer.phar install\r\n\r\n```\r\n\r\n## Usage\r\n\r\n### Overview\r\n\r\nHere is the minimum that is required. You'll need to construct the Transcoder with a \\Optimus\\EventDispatcher instance\r\nand provide it with a \\DOMDocument. You can configure as many listeners/transforms as you want and add them to the\r\nevent dispatcher. Then you can fetch the transcoded output from the Transcoder.\r\n\r\n```php\r\nuse Optimus\\EventDispatcher,\r\n    Optimus\\Transcoder;\r\n\r\n$dispatcher = new EventDispatcher();\r\n$transcoder = new Transcoder($dispatcher);\r\n$transcoder->setDocument($domDocument); // $domDocument is obtained elsewhere\r\n\r\n// Add your listeners/transformers to the event dispatcher...\r\n\r\n/** @var \\DOMDocument $output */\r\n$output = $transcoder->transcode();\r\n```\r\n\r\n### Adding custom listeners\r\n\r\nBecause the Event Dispatcher directly extends the Symfony2 EventDispatcher component you're able to add your own listeners,\r\nwhich can be anything that is callable. e.g.\r\n\r\n```php\r\nuse Optimus\\Event\\TranscodeElementEvent;\r\n\r\n# Remove all script nodes from the DOMDocument.\r\n$dispatcher->addListener('div', function(TranscodeElementEvent $event) {\r\n  $event->removeNode(); // also stops propagation as there's no point continuing\r\n});\r\n\r\n# Listen for all nodes in the DOMDocument. NOTE: this does not include text nodes\r\n$dispatcher->addListener('*', function(TranscodeElementEvent $event) {\r\n  /** @var \\DOMElement $node **/\r\n  $node = $event->getNode();\r\n\r\n  if ($node->nodeName === 'script') {\r\n    throw new \\Exception('This should never get thrown as the specific div listener is stopping propagation');\r\n  }\r\n\r\n  // your custom logic\r\n  $node->setAttribute('data-transcoded', 1);\r\n});\r\n```\r\n\r\nThe event name to listen to is the name of the node (i.e. 'div' or 'ul') or a wilcard character, '*', which can be used to\r\nlisten to all element nodes. This 'wildcard' event is dispatched after the specific one for the node and uses  the same\r\nevent instance, so if the propagation was stopped in a listener to the 'node name' event then the wildcard event will not\r\nbe dispatched.\r\n\r\n### Adding Transformers\r\n\r\nA simpler option is to use a Transformer object. For example:\r\n\r\n```php\r\nuse Optimus\\Transformer\\AddPositionClassTransformer;\r\n\r\n# Transform all nodes in the DOMDocument\r\n$dispatcher->addTransformer('*', new AddPositionClassTransformer());\r\n```\r\n\r\nThis method also allows you to specify multiple selectors at once for convenience. Behind the scenes this will add a listener\r\nfor each selector given. e.g.\r\n\r\n```php\r\nuse Optimus\\Transformer\\AddPositionClassTransformer;\r\n\r\n# Add position classes to all <div> and <li> nodes in the document\r\n$transformer = new AddPositionClassTransformer();\r\n$dispatcher->addTransformer(['div', 'li'], $transformer);\r\n```\r\n\r\n### Using Constraints to control when a Transformer will be applied\r\n\r\nThe main benefit to using a Transformer rather than any other listener is that it allows you much greater control over\r\nwhen the Transformer is dispatched events. This is achieved by configuring any number of Constraint objects and adding\r\nthem to the Transformer. e.g.\r\n\r\n```php\r\nuse Optimus\\Constraint\\DepthConstraint;\r\n\r\n# Only transform nodes that are nested at least 5 levels deep in the DOM, but no more than 10,\r\n$transformer->addConstraint(new DepthConstraint(5, 10));\r\n$dispatcher->addTransformer('*', $transformer);\r\n```\r\n\r\nFor added convenience, certain constraints can be added by specifying them as a CSS selector when adding the Transformer\r\nto the Event Dispatcher. e.g.\r\n\r\n```php\r\nuse Optimus\\Constraint\\HasAttributeConstraint,\r\n    Optimus\\Constraint\\HasClassConstraint;\r\n\r\n# Adding an id constraint for any tag\r\n$transformer->addConstraint(new HasAttributeConstraint('id', 'container'));\r\n$dispatcher->addTransformer('*', $transformer);\r\n\r\n// ...can be written shorter as:\r\n$dispatcher->addTransformer('#container', $transformer);\r\n\r\n\r\n# Adding class constraint(s) for <li> tags\r\n$transformer->addConstraint(new HasClassConstraint(['first', 'selected']));\r\n$dispatcher->addTransformer('li', $transformer);\r\n\r\n// ...can be written shorter as:\r\n$dispatcher->addTransformer('li.first.selected', $transformer);\r\n```\r\n\r\n### Combining Constraints in a Composite for even greater control\r\n\r\nYou'll only be able to achieve so much by adding individual Constraints to a Transformer that all need to be satisfied.\r\nIt's likely there will be times when you want to transform a node if one of any number of conditions are met, and this can\r\nbe achieved by adding any number of Constraints to the CompositeConstraint. As the name implies this also implements the\r\nOptimus\\Constraint\\ConstraintInterface so it can be added to a Transformer the same as any other Constraint. e.g.\r\n\r\n```php\r\nuse Optimus\\Constraint\\CompositeConstraint,\r\n    Optimus\\Constraint\\HasAttributeConstraint,\r\n    Optimus\\Constraint\\HasClassConstraint;\r\n\r\n# Listen to <ul> tags that have 'nav' anywhere in their id, or have a 'nav' class\r\n$idConstraint = new HasAttributeConstraint('id');\r\n$idConstraint->setPattern('/nav/');\r\n$transformer->addConstraint(new CompositeConstraint([\r\n    $idConstraint,\r\n    new HasClassConstraint('nav')\r\n]));\r\n```\r\n\r\nBy default the CompositeConstraint uses the `CompositeConstraint::MODE_ANY` mode; it will return true if any of the Constraints\r\ngiven to it are satisfied. There are two other modes to choose from: `CompositeConstraint::MODE_ALL` or `CompositeConstraint::MODE_NONE`.\r\nMODE_ALL is probably going to be the least used as this is the default behaviour when adding Constraints directly to a\r\nTransformer - it is really only necessary when nesting CompositeConstraints inside each other. MODE_NONE, on the other hand,\r\nis very useful as it allows you to specify when a Transformer should NOT be applied. e.g.\r\n\r\n```php\r\nuse Optimus\\Constraint\\CompositeConstraint,\r\n    Optimus\\Constraint\\HasAttributeConstraint;\r\n\r\n# Listen to all <input> nodes except checkboxes and radio buttons\r\n$compositeConstraint = new CompositeConstraint();\r\n$compositeConstraint\r\n    ->setMode(CompositeConstraint::MODE_NONE)\r\n    ->addConstraint(new HasAttributeConstraint('type', 'checkbox'))\r\n    ->addConstraint(new HasAttributeConstraint('type', 'radio'))\r\n;\r\n$transformer->addConstraint($compositeConstraint);\r\n$dispatcher->addTransformer('input', $transformer);\r\n```\r\n\r\n## Testing\r\n\r\nFirst, you must ensure you've installed all of the dev dependencies via composer:\r\n\r\n```\r\n$ php composer.phar install --dev\r\n\r\n```\r\n\r\nThen simply run the phpunit executable in the vendor directory:\r\n\r\n```\r\n$ vendor/bin/phpunit\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}